/*
Gramatica para el Robot:
Autor: Alejandro Arango
Modificado por: Silvia Takahashi
Modificado por: Juan Pablo Morales.
Agregadas producciones para manejar globos
Modificado por Silvia Takahashi
**/


options 
{
  
	LOOKAHEAD=1; 
	IGNORE_CASE=true;
	STATIC = false;
	
}
   

PARSER_BEGIN(Robot)

package uniandes.lym.robot.control;

import uniandes.lym.robot.kernel.*;
import uniandes.lym.robot.view.Console;

import java.util.HashMap;
import java.util.Map;
import java.util.List;
import java.util.ArrayList;
import java.awt.Point;
import java.io.*;
import java.util.Vector;
import java.util.LinkedList;

@SuppressWarnings("serial")
public class Robot 
{
	public static Map<String, Integer> variableMap = new HashMap<>();
	public static Map<String, List<String>> functionMap = new HashMap<>();
	public static Map<String, String> paramFunctionMap = new HashMap<>();
	public static String salida = new String();
	
	private RobotWorldDec world;
	
	
	void setWorld(RobotWorld w) {
		world = (RobotWorldDec) w;	
	}
}
PARSER_END(Robot)

SKIP:
{
	" "
	|	"\r"
	|	"\t"
	| "\n"
}

TOKEN: /*Commands*/
{
	 <ASSIGN: "=">
	| <MOVE:  "move">
	| <NAME: "name"> 
	| <ROBOTSKIP: "skip">
	| <TURN: "turn">
	| <FACE: "face">
	| <PUT: "put" >
	| <PICK: "pick" >
	| <MOVEDIR: "move-dir" >
	| <RUNDIRS: "run-dirs">
	| <MOVEFACE: "move-face">
	| <NULL: "null">		

}

TOKEN: /*Constants*/
{
	<ITEM: ":balloons" | ":chips" >
	| <DIRECTION: ":left" | ":right" | ":around" | ":front" | ":back">
	| <ORIENTATION: ":north" | ":south" | ":west" | ":east">
	| <CONSTANT: "dim" | "myxpos" | "myypos" | "mychips" | "myballons" | "ballonshere" | "chipshere" | "spaces" >

}

TOKEN: /*Conditions and Conditionals*/
{
	<IF: "if">
	| <LOOP: "loop">
	| <REPEAT: "repeat"> 
	| <FACING: "facing?">
	| <BLOCKED: "blocked?">
	| <CANPUT: "can-put?">
	| <CANPICK: "can-pick?">
	| <CANMOVE: "can-move?">
	| <ISZERO: "isZero?">
	| <NOT: "not">
}

TOKEN : /*Additional Tokens*/
{
	<NUM: (<DIGIT>)+ > 
	| <LPAREN: "(">
	| <RPAREN: ")">
	| <DEFVAR: "defvar">
	| <DEFUN: "defun">
	| <WORD: (["a"-"z", "0"-"9"])+ >
	| <#DIGIT: ["0"-"9"] >   
}

/*Variable and Procedure Definitions*/
void varDefinition() :
{
  Token variableName;
  int variableValue;
  
}
{
  <DEFVAR>(variableName = <WORD>)variableValue = value()<RPAREN>
  {Robot.variableMap.put(variableName.image, variableValue);}
}

void procedureDefinition() :
{
  Token tokenFunName;
  List<String> paramsList = new ArrayList<>();
}
{
  <DEFUN>(tokenFunName = <WORD>){
	Robot.functionMap.put(tokenFunName.image, paramsList);
    }(<LPAREN>(params(tokenFunName.image))<RPAREN>)(<LPAREN>instruction(false))+<RPAREN>
    {
      Robot.paramFunctionMap.clear();
    }
}

void params(String funName) :
{
  Token tokenParamName;
}
{
  (tokenParamName = <WORD> {
	Robot.functionMap.get(funName).add(tokenParamName.image);
	Robot.paramFunctionMap.put(tokenParamName.image, funName);
    })*
}

/*Instructions*/
void instruction(boolean runWorld) :
{}
{
  //TODO: Revisar si procedureCall necesita runWorld (creería que si porque dentro se pueden tener estructuras de control, en particular if's)
  (procedureCall()|parseCommand(runWorld)|controlStructure(runWorld))<RPAREN>
}

void block(boolean runWorld) :
{}
{
  <LPAREN>(<LPAREN>instruction(runWorld))+<RPAREN>
}

//TODO: Modificar para que en efecto corra la función
void procedureCall() :
{
  Token funName;
  List<String> paramTokens = new ArrayList<>();
}
{
  (funName = <WORD>)(<NUM>{paramTokens.add(token.image);}|
  <CONSTANT>{paramTokens.add(token.image);}|
  varCall(){paramTokens.add(token.image);})*
  {
    if (paramTokens.size() != Robot.functionMap.get(funName.image).size())
    {
      throw new ParseException("Error: La cantidad de parámetros ingresados no coincide con la cantidad esperada.");
    }
  }
}

void parseCommand(boolean runWorld) :
{}
{
  (assign(runWorld)
  |move(runWorld)
  |skip(runWorld)
  |turn(runWorld)
  |face(runWorld)
  |put(runWorld)
  |pick(runWorld)
  |moveDir(runWorld)
  |runDirs(runWorld)
  |moveFace(runWorld)
  |nullCommand()
  )
  
}

/*Commands*/
void assign(boolean runWorld):
{
  String variableName;
  int variableValue;
}
{
  < ASSIGN >< WORD >
  //No se llama varCall() porque permitiría que se hiciera assign sobre el parámetro de una función
  {
    variableName = token.image;
    if (!Robot.variableMap.containsKey(variableName))
    {
      throw new ParseException("Error: La variable " + variableName + " no está definida.");
    }
  }
  variableValue = value()
  {
    if (variableValue != -1 && runWorld)
    {
      Robot.variableMap.put(variableName, variableValue);
      Robot.salida = "Command: variable assignment";
    }
  }
}

void move(boolean runWorld):
{int numberSteps;}
{
  < MOVE >numberSteps=value()
  {
    if (numberSteps != -1 && runWorld)
    {
      world.moveForward(numberSteps, false);
      Robot.salida = "Command: move";
    }
  }
}

void skip(boolean runWorld):
{
  int numberValue;

}
{
  < ROBOTSKIP > numberValue = value()
  {
    if (numberValue != -1 && runWorld)
    {
      world.moveForward(numberValue, true);
      Robot.salida = "Command: skip";
    }
  }
}

void turn(boolean runWorld):
{String direction;}
{
  < TURN >< DIRECTION >
  {
    if (runWorld)
    {
      direction = token.image;
      switch(direction) {
	    case ":left":
	        world.turnRight();
	        world.turnRight();
	        world.turnRight();
	        break;
	    case ":right":
	        world.turnRight();
	        break;
	    case ":around":
	        world.turnRight();
	        world.turnRight();
	        break;
	    default:
	        throw new ParseException("Error: la dirección " + token.image + " no es válida con el comando turn.");
		}
      Robot.salida = "Command: turn";
    }
  }
}

void face(boolean runWorld):
{
  String orientationTokenValue;
  int orientationValue = -1;
}
{
  < FACE >< ORIENTATION >
  {
    if (runWorld)
    {
      orientationTokenValue = token.image;
      if(orientationTokenValue.equals(":north"))
      {
        orientationValue = 0;
      }
      else if (orientationTokenValue.equals(":south"))
      {
        orientationValue = 1;
      }
      else if (orientationTokenValue.equals(":east"))
      {
        orientationValue = 2;
      }
      else if (orientationTokenValue.equals(":west"))
      {
        orientationValue = 3;
      }
      while (world.getFacing() != orientationValue)
      {
        world.turnRight();
      }
      Robot.salida = "Command: face";
    }
  }
}

void put(boolean runWorld):
{
  Token itemToken;
  int numberItem;
}
{
  < PUT >(itemToken =  < ITEM >) numberItem=value()
  {
    if (numberItem != -1 && runWorld)
    {
      if (itemToken.image.equals(":balloons"))
      {
        world.putBalloons(numberItem);
      }
      else if (itemToken.image.equals(":chips"))
      {
        world.putChips(numberItem);
      }
      Robot.salida = "Command: put";
    }
  }
}

void pick(boolean runWorld):
{
  Token itemToken;
  int numberItem;
}
{
  < PICK >(itemToken = < ITEM >) numberItem=value()
  {
    if (numberItem != -1 && runWorld)
    {
      if (itemToken.image.equals(":balloons"))
      {
        world.grabBalloons(numberItem);
      }
      else if (itemToken.image.equals(":chips"))
      {
        world.pickChips(numberItem);
      }
      Robot.salida = "Command: pick";
    }
  }
}

void moveDir(boolean runWorld):
{
  Token itemToken;
  int initialOrientation;
  int numberItem;
  }
{
  < MOVEDIR > numberItem=value()(itemToken = direction())
  {
    if (numberItem != -1 && runWorld)
    {
      //guardar orientacion inicial
      initialOrientation = world.getFacing();
      if (itemToken.image.equals(":right"))
      {
        world.turnRight();
        world.moveForward(numberItem, false);
      }
      else if (itemToken.image.equals(":left"))
      {
        world.turnRight();
        world.turnRight();
        world.turnRight();
        world.moveForward(numberItem, false);
	  }
	  else if (itemToken.image.equals(":front"))
	  {
	    world.moveForward(numberItem, false);
	  }
	  else if (itemToken.image.equals(":back"))
	  {
	    world.turnRight();
	    world.turnRight();
	    world.moveForward(numberItem, false);
	  }//Volver a orientacion de inicio
	  while (world.getFacing() != initialOrientation)
	  {
	    world.turnRight();
	  }
	  Robot.salida = "Command: move-dir";
    }
  }
}

void runDirs(boolean runWorld):
{
  List<String> directionsList = new ArrayList<>();
  Token directionReturn;
  int initialOrientation;
}
{
  < RUNDIRS >(directionReturn = direction() {
    directionsList.add(directionReturn.image);
    })+
  {
    if (runWorld)
    {
      for (String direction : directionsList)
      {
        initialOrientation = world.getFacing();
        
        if (direction.equals(":right"))
        {
          world.turnRight();
          world.moveForward(1, false);
        }
        else if (direction.equals(":left"))
        {
          world.turnRight();
          world.turnRight();
          world.turnRight();
          world.moveForward(1, false);
        }
        else if (direction.equals(":front"))
        {
          world.moveForward(1, false);
        }
        else if (direction.equals(":back"))
        {
          world.turnRight();
          world.turnRight();
          world.moveForward(1, false);
        }
		//Volver a orientacion de inicio
        while (world.getFacing() != initialOrientation)
        {
          world.turnRight();
        }
      }
      Robot.salida = "Command: rund dirs";
    }
  }
}

void moveFace(boolean runWorld):
{
  Token orientationToken;
  int moveValue;
  String orientationTokenValue;
  int orientationValue = -1;
}
{
  < MOVEFACE >moveValue = value()(orientationToken = < ORIENTATION >)
  {
    if (moveValue != -1 && runWorld)
    {
      orientationTokenValue = orientationToken.image;
      if(orientationTokenValue.equals(":north"))
      {
        orientationValue = 0;
      }
      else if (orientationTokenValue.equals(":south"))
      {
        orientationValue = 1;
      }
      else if (orientationTokenValue.equals(":east"))
      {
        orientationValue = 2;
      }
      else if (orientationTokenValue.equals(":west"))
      {
        orientationValue = 3;
      }
      while (world.getFacing() != orientationValue)
      {
        world.turnRight();
      }
      world.moveForward(moveValue, false);
      Robot.salida = "Command: move-face";
    }
  }
}

void nullCommand():
{}
{
  < NULL >
}

/*Control Structures*/
void controlStructure(boolean runWorld) :
{}
{
  (conditional(runWorld)|repeat(runWorld)|repeatTimes(runWorld))
}

void repeat(boolean runWorld) :
{}
{
  <LOOP>condition()(parseCommand(runWorld)|block(runWorld))
}

void repeatTimes(boolean runWorld) :
{}
{
  <REPEAT>value()(parseCommand(runWorld)|block(runWorld))
}

/*Conditionals*/
void conditional(boolean runWorld) :
{
  boolean conditionReturn;
}
{
  //TODO: Revisar si condition necesita runWorld
  <IF>(conditionReturn = condition())
  {
    if (runWorld)
    {
      if (conditionReturn)
      {
        block(true);
        block(false);
      }
      else
      {
        block(false);
        block(true);
      }
    }
    else
    {
      block(false);
      block(false);
    }
  }
}

boolean condition() :
{
  boolean valueReturn;
  }
{
  <LPAREN>(valueReturn = facingCondition()
  |valueReturn = blockedCondition()
  |valueReturn = canputCondition()
  |valueReturn = canpickCondition()
  |valueReturn = canmoveCondition()
  |valueReturn = iszeroCondition()
  |valueReturn = notCondition())
  <RPAREN>
  {
    System.out.println(valueReturn);
    return valueReturn;
  }
}

boolean facingCondition() :
{
  Token orientationToken;
  String orientationTokenValue;
  int orientationValue = -1;
  boolean returnValue;
}
{
  <FACING>(orientationToken = <ORIENTATION>)
  {
    orientationTokenValue = orientationToken.image;
    if(orientationTokenValue.equals(":north")) {
      orientationValue = 0;
      } else if (orientationTokenValue.equals(":south")) {
        orientationValue = 1;
      } else if (orientationTokenValue.equals(":east")) {
        orientationValue = 2;
      } else if (orientationTokenValue.equals(":west")) {
		orientationValue = 3;
        }
     if (orientationValue == world.getFacing()) {
       returnValue = true;
        } else {
        returnValue = false;
          }
     return returnValue;
  }
}

boolean blockedCondition() :
{
  Point position;
  int orientationValue;
  boolean returnValue = false;
}
{
  <BLOCKED>
  {
    orientationValue = world.getFacing();
    position = world.getPosition();
    if (orientationValue == 0) {
      position.y -= 1;
     } else if (orientationValue == 1) {
       position.y +=1;
     } else if (orientationValue == 2) {
       position.x +=1;
     } else if (orientationValue == 3) {
       position.x -=1;
     }
     returnValue = world.isBlocked(position);
     return returnValue;
  } 
}

boolean canputCondition() :
{
  boolean returnValue = false;
}
{
  <CANPUT><ITEM>value()
  {
    return returnValue;
  }
}

boolean canpickCondition() :
{
  boolean returnValue = false;
}
{
  <CANPICK><ITEM>value()
  {
    return returnValue;
  }
}

boolean canmoveCondition() :
{
  boolean outOfBounds = false;
  boolean canMove = false;
  Token tokenOrientation;
  String orientationTokenValue;
  Point position = world.getPosition();
}
{
 <CANMOVE>(tokenOrientation = <ORIENTATION>)
 
 {
   orientationTokenValue = tokenOrientation.image;
   if(orientationTokenValue.equals(":north")) {
      position.y -= 1;
      
      //comprobar si está dentro del tablero
    if (position.y > world.getN() || position.y < 1) {
      outOfBounds = true;
      }
        
      } else if (orientationTokenValue.equals(":south")) {
        position.y += 1;

        //comprobar si está dentro del tablero
    	if (position.y > world.getN() || position.y < 1) {
      		outOfBounds = true;
      		}
        
      } else if (orientationTokenValue.equals(":east")) {
        position.x += 1;
        
        if (position.x > world.getN() || position.x < 1) {
      		outOfBounds = true;
      	}
        
      } else if (orientationTokenValue.equals(":west")) {
		position.x -= 1;

		//comprobar si está dentro del tablero
		if (position.x > world.getN() || position.x < 1) {
      		outOfBounds = true;
      	}
        }
        
    //comprobar isBlocked
    if (!world.isBlocked(position) && !outOfBounds) {
      canMove = true;
      }
        
   return canMove;
 } 
}

boolean iszeroCondition() :
{
  boolean returnBoolValue = false;
  int returnNumberValue;
}
{
  <ISZERO>(returnNumberValue = value())
  {
    if (returnNumberValue == 0) {
      returnBoolValue = true;
      }
    return returnBoolValue;
  }
}

boolean notCondition() :
{
  boolean returnValue = false;
  boolean conditionValue = false;
}
{
  <NOT>(conditionValue = condition())
  {
    if (!conditionValue) {
      returnValue = true;
      }
    return returnValue;
  }
}

/* Auxiliary Functions*/
int varCall():
{
	int value = -1;
}
{
  <WORD>
  {
    if (Robot.variableMap.containsKey(token.image))
    {
      try
      {
        value = Robot.variableMap.get(token.image);
      }
      catch (NumberFormatException ee)
      {
        throw new Error("Hay overflow con el valor: "+value);
      }

      return value;
    }
    if (!Robot.variableMap.containsKey(token.image)) {
		if (!Robot.paramFunctionMap.containsKey(token.image)) {
			throw new ParseException("Error: La variable " + token.image + " no está definida.");
        }
    }
    
    return value; //Si se retorna -1 significa que el varCall() corresponde al parámetros de una función
  }
}

int value() throws Error:
{int value = -1;}
{
  (<NUM>
  {
    try
    {
      value = Integer.parseInt(token.image);
    }
   	catch (NumberFormatException ee) 
		{
			throw new Error("Hay overflow con el valor: "+token.image);
		}
	return value;
  }
  |<CONSTANT>
  {
    String image = token.image;
  	if (image.equals("dim")) { value = world.getN(); }
  	else if (image.equals("myxpos")) { value = (int) world.getPosition().getX(); }
  	else if (image.equals("myypos")) { value = (int) world.getPosition().getY(); }
  	else if (image.equals("mychips")) { value = world.getMyChips(); }
  	else if (image.equals("myballons")) { value = world.getMyBalloons(); }
  	else if (image.equals("ballonshere")) { value = world.countBalloons(); }
	else if (image.equals("chipshere")) { value = world.chipsToPick(); }
  	else if (image.equals("spaces")) { value = world.freeSpacesForChips(); }
  
	return value;
  }
  |value = varCall()
  {	return value; })//Si se retorna -1 significa que el varCall() corresponde al parámetros de una función
}

//value() retorna el valor numérico para usarlo con los métodos de world

Token direction():
{
  Token directionToken;
}
{
  directionToken = < DIRECTION >
  {
    if (!(token.image.equals(":front") || token.image.equals(":right") || token.image.equals(":left") || token.image.equals(":back"))) {
		throw new ParseException("Error: la dirección " + token.image + " no es válida con el comando move-dir o run-dirs.");
    }
    return directionToken;
  }
}

//Initial Rule
boolean command(Console sistema):
{}
{//TODO: Revisar var y procedure Definition para ver si se necesita runWorld
	(<LPAREN>(varDefinition()|procedureDefinition()|instruction(true)) 
	{
	    try {
    			 Thread.sleep(900);
    	    } catch (InterruptedException e) {
    			        System.err.format("IOException: %s%n", e);
    		    }

		sistema.printOutput(salida);
		return true;
	})+

	| <EOF> {return false;} 
}

//void put() :
//{
//	int f=1;	
//}
//{
//	( <CHIPS>    "," f=num() {world.putChips(f); salida = "Command:  Put Chips"; })
//	|  	  ( <BALLOONS>   "," f=num() {world.putBalloons(f); salida = "Command:  Put Balloons";})	 
//
//}
//
//void get() :
//{
//	int f=1;	
//}
//{
//	( <CHIPS>   "," f=num() {world.pickChips(f);salida = "Command:  Pick chips";})
//	|  	  ( <BALLOONS>   "," f=num() {world.grabBalloons(f);salida="Command:  Pick balloons";})	 
//
//}
