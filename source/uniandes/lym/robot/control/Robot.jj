/*
Gramatica para el Robot:
Autor: Alejandro Arango
Modificado por: Silvia Takahashi
Modificado por: Juan Pablo Morales.
Agregadas producciones para manejar globos
Modificado por Silvia Takahashi
**/


options 
{
  
	LOOKAHEAD=1; 
	IGNORE_CASE=true;
	STATIC = false;
	
}
   

PARSER_BEGIN(Robot)

package uniandes.lym.robot.control;

import uniandes.lym.robot.kernel.*;
import uniandes.lym.robot.view.Console;

import java.util.HashMap;
import java.util.Map;
import java.util.List;
import java.util.ArrayList;
import java.awt.Point;
import java.io.*;
import java.util.Vector;
import java.util.LinkedList;

@SuppressWarnings("serial")
public class Robot 
{
	public static Map<String, Integer> variableMap = new HashMap<>();
	public static Map<String, List<String>> functionMap = new HashMap<>();
	public static Map<String, String> paramFunctionMap = new HashMap<>();
	public static String salida = new String();
	
	private RobotWorldDec world;
	
	
	void setWorld(RobotWorld w) {
		world = (RobotWorldDec) w;	
	}
}
PARSER_END(Robot)

SKIP:
{
	" "
	|	"\r"
	|	"\t"
	| "\n"
}

TOKEN: /*Commands*/
{
	 <ASSIGN: "=">
	| <MOVE:  "move">
	| <NAME: "name"> 
	| <ROBOTSKIP: "skip">
	| <TURN: "turn">
	| <FACE: "face">
	| <PUT: "put" >
	| <PICK: "pick" >
	| <MOVEDIR: "move-dir" >
	| <RUNDIRS: "run-dirs">
	| <MOVEFACE: "move-face">
	| <NULL: "null">		

}

TOKEN: /*Constants*/
{
	<ITEM: ":balloons" | ":chips" >
	| <DIRECTION: ":left" | ":right" | ":around" | ":front" | ":back">
	| <ORIENTATION: ":north" | ":south" | ":west" | ":east">
	| <CONSTANT: "dim" | "myxpos" | "myypos" | "mychips" | "myballons" | "ballonshere" | "chipshere" | "spaces" >

}

TOKEN: /*Conditions and Conditionals*/
{
	<IF: "if">
	| <LOOP: "loop">
	| <REPEAT: "repeat"> 
	| <FACING: "facing?">
	| <BLOCKED: "blocked?">
	| <CANPUT: "can-put?">
	| <CANPICK: "can-pick?">
	| <CANMOVE: "can-move?">
	| <ISZERO: "isZero?">
	| <NOT: "not">
}

TOKEN : /*Additional Tokens*/
{
	<NUM: (<DIGIT>)+ > 
	| <LPAREN: "(">
	| <RPAREN: ")">
	| <DEFVAR: "defvar">
	| <DEFUN: "defun">
	| <WORD: (["a"-"z", "0"-"9"])+ >
	| <#DIGIT: ["0"-"9"] >   
}

/*Variable and Procedure Definitions*/
void varDefinition() :
{
  Token variableName;
  int variableValue;
  
}
{
  <DEFVAR>(variableName = <WORD>)variableValue = value()<RPAREN>
  {Robot.variableMap.put(variableName.image, variableValue);}
}

void procedureDefinition() :
{
  Token tokenFunName;
  List<String> paramsList = new ArrayList<>();
}
{
  <DEFUN>(tokenFunName = <WORD>){
	Robot.functionMap.put(tokenFunName.image, paramsList);
    }(<LPAREN>(params(tokenFunName.image))<RPAREN>)(<LPAREN>instruction())+<RPAREN>
    {
      Robot.paramFunctionMap.clear();
    }
}

void params(String funName) :
{
  Token tokenParamName;
}
{
  (tokenParamName = <WORD> {
	Robot.functionMap.get(funName).add(tokenParamName.image);
	Robot.paramFunctionMap.put(tokenParamName.image, funName);
    })*
}

/*Instructions*/
void instruction() :
{}
{
  (procedureCall()|parseCommand()|controlStructure())<RPAREN>
}

void block() :
{}
{
  <LPAREN>(<LPAREN>instruction())+<RPAREN>
}

void procedureCall() :
{
  Token funName;
  List<String> paramTokens = new ArrayList<>();
}
{
  (funName = <WORD>)(<NUM> | <CONSTANT> | varCall() //Cambié que no se retornara token en varCall(), pero esto debería funcionar porque
  													//al leer el token en varCall() se actualiza la global token
	{
	  paramTokens.add(token.image);
	}
  )*
	{
	  if (paramTokens.size() != Robot.functionMap.get(funName).size()) {
		throw new ParseException("Error: los parámetros de ingreso no coinciden con los esperados.");
	    }	
	}

  
}

void parseCommand() :
{}
{
  (assign()
  |move()
  |skip()
  |turn()
  |face()
  |put()
  |pick()
  |moveDir()
  |runDirs()
  |moveFace()
  |nullCommand()
  )
  
}

/*Commands*/
void assign():
{
  String variableName;
  int variableValue;
}
{
  < ASSIGN >< WORD >
  //No se llama varCall() porque permitiría que se hiciera assign sobre el parámetro de una función
  {
    variableName = token.image;
    if (!Robot.variableMap.containsKey(variableName))
    {
      throw new ParseException("Error: La variable " + variableName + " no está definida.");
    }
  }
  variableValue = value()
  {
    Robot.variableMap.put(variableName, variableValue);
    Robot.salida = "Command: variable assignment";
  }
}

void move():
{int numberSteps;}
{
  < MOVE >numberSteps=value()
  {
    if (numberSteps != -1)
    {
      world.moveForward(numberSteps, false);
      Robot.salida = "Command: move";
    }
  }
}

void skip():
{
  int numberValue;

}
{
  < ROBOTSKIP > numberValue = value()
  {
    world.moveForward(numberValue, true);
    Robot.salida = "Command: skip";
  }
}

void turn():
{String direction;}
{
  < TURN >< DIRECTION >
  {
    direction = token.image;
	switch(direction) {
	    case ":left":
	        world.turnRight();
	        world.turnRight();
	        world.turnRight();
	        break;
	    case ":right":
	        world.turnRight();
	        break;
	    case ":around":
	        world.turnRight();
	        world.turnRight();
	        break;
	    default:
	        throw new ParseException("Error: la dirección " + token.image + " no es válida con el comando turn.");
	}
	Robot.salida = "Command: turn";
  }
}

void face():
{String orientationTokenValue;
int orientationValue = -1;
}
{
  < FACE >< ORIENTATION >
  {
    orientationTokenValue = token.image;
    if(orientationTokenValue.equals(":north")) {
      orientationValue = 0;
      } else if (orientationTokenValue.equals(":south")) {
        orientationValue = 1;
      } else if (orientationTokenValue.equals(":east")) {
        orientationValue = 2;
      } else if (orientationTokenValue.equals(":west")) {
		orientationValue = 3;
        }
     while (world.getFacing() != orientationValue) {
       world.turnRight();
       }
       Robot.salida = "Command: face";
  }
}

void put():
{
  Token itemToken;
  int numberItem;
  }
{
  < PUT >(itemToken =  < ITEM >) numberItem=value()
  {
    if (itemToken.image.equals(":balloons")) {
      world.putBalloons(numberItem);
      } else if (itemToken.image.equals(":chips")) {
        world.putChips(numberItem);
        }
    Robot.salida = "Command: put";
  }
}

void pick():
{
  Token itemToken;
  int numberItem;
  }
{
  < PICK >(itemToken = < ITEM >) numberItem=value()
  {
    if (itemToken.image.equals(":balloons")) {
      world.grabBalloons(numberItem);
      } else if (itemToken.image.equals(":chips")) {
        world.pickChips(numberItem);
        }
    Robot.salida = "Command: pick";
  }
}

void moveDir():
{
  Token itemToken;
  int initialOrientation;
  int numberItem;
  }
{
  < MOVEDIR > numberItem=value()(itemToken = direction())
  {
    //guardar orientacion inicial
    initialOrientation = world.getFacing();
	
    if (itemToken.image.equals(":right")) {
      world.turnRight();
      world.moveForward(numberItem, false);
      } else if (itemToken.image.equals(":left")) {
        world.turnRight();
        world.turnRight();
        world.turnRight();
        world.moveForward(numberItem, false);
       } else if (itemToken.image.equals(":front")) {
         world.moveForward(numberItem, false);
         } else if (itemToken.image.equals(":back")) {
		 world.turnRight();
		 world.turnRight();
         world.moveForward(numberItem, false);
         }
     //Volver a orientacion de inicio
     while (world.getFacing() != initialOrientation) {
       world.turnRight();
       }
    Robot.salida = "Command: move-dir";
  }
}

void runDirs():
{
  List<String> directionsList = new ArrayList<>();
  Token directionReturn;
  int initialOrientation;
}
{
  < RUNDIRS >(directionReturn = direction() {
    directionsList.add(directionReturn.image);
    })+
  {
    for (String direction : directionsList) {

      initialOrientation = world.getFacing();
	
     if (direction.equals(":right")) {
      	world.turnRight();
      	world.moveForward(1, false);
      } else if (direction.equals(":left")) {
        world.turnRight();
        world.turnRight();
        world.turnRight();
        world.moveForward(1, false);
       } else if (direction.equals(":front")) {
         world.moveForward(1, false);
         } else if (direction.equals(":back")) {
		 world.turnRight();
		 world.turnRight();
         world.moveForward(1, false);
         }
     //Volver a orientacion de inicio
     while (world.getFacing() != initialOrientation) {
       world.turnRight();
       }
      }

      Robot.salida = "Command: rund dirs";
  }
}

void moveFace():
{
  Token orientationToken;
  int moveValue;
  String orientationTokenValue;
  int orientationValue = -1;
  }
{
  < MOVEFACE >moveValue = value()(orientationToken = < ORIENTATION >)
  {
    orientationTokenValue = orientationToken.image;
    if(orientationTokenValue.equals(":north")) {
      orientationValue = 0;
      } else if (orientationTokenValue.equals(":south")) {
        orientationValue = 1;
      } else if (orientationTokenValue.equals(":east")) {
        orientationValue = 2;
      } else if (orientationTokenValue.equals(":west")) {
		orientationValue = 3;
        }
     while (world.getFacing() != orientationValue) {
       world.turnRight();
       }
       world.moveForward(moveValue, false);
       Robot.salida = "Command: move-face";
  }
}

void nullCommand():
{}
{
  < NULL >
}

/*Control Structures*/
void controlStructure() :
{}
{
  (conditional()|repeat()|repeatTimes())
}

void repeat() :
{}
{
  <LOOP>condition()(parseCommand()|block())
}

void repeatTimes() :
{}
{
  <REPEAT>value()(parseCommand()|block())
}

/*Conditionals*/
void conditional() :
{
  boolean conditionReturn;
}
{
  <IF>(conditionReturn = condition())(block())(block())
}

boolean condition() :
{
  boolean valueReturn;
  }
{
  <LPAREN>(valueReturn = facingCondition()
  |valueReturn = blockedCondition()
  |valueReturn = canputCondition()
  |valueReturn = canpickCondition()
  |valueReturn = canmoveCondition()
  |valueReturn = iszeroCondition()
  |valueReturn = notCondition())
  <RPAREN>
}

boolean facingCondition() :
{
  Token orientationToken;
  String orientationTokenValue;
  int orientationValue = -1;
  boolean returnValue;
}
{
  <FACING>(orientationToken = <ORIENTATION>)
  {
    orientationTokenValue = orientationToken.image;
    if(orientationTokenValue.equals(":north")) {
      orientationValue = 0;
      } else if (orientationTokenValue.equals(":south")) {
        orientationValue = 1;
      } else if (orientationTokenValue.equals(":east")) {
        orientationValue = 2;
      } else if (orientationTokenValue.equals(":west")) {
		orientationValue = 3;
        }
     if (orientationValue == world.getFacing()) {
       returnValue = true;
        } else {
        returnValue = false;
          }
     return returnValue;
  }
}

void blockedCondition() :
{}
{
  <BLOCKED>
}

void canputCondition() :
{}
{
  <CANPUT><ITEM>value()
}

void canpickCondition() :
{}
{
  <CANPICK><ITEM>value()
}

void canmoveCondition() :
{}
{
 <CANMOVE><ORIENTATION> 
}

void iszeroCondition() :
{}
{
  <ISZERO>value()
}

void notCondition() :
{}
{
  <NOT>condition()
}

/* Auxiliary Functions*/
int varCall():
{
	int value = -1;
}
{
  <WORD>
  {
    if (Robot.variableMap.containsKey(token.image))
    {
      try
      {
        value = Robot.variableMap.get(token.image);
      }
      catch (NumberFormatException ee)
      {
        throw new Error("Hay overflow con el valor: "+value);
      }

      return value;
    }
    if (!Robot.variableMap.containsKey(token.image)) {
		if (!Robot.paramFunctionMap.containsKey(token.image)) {
			throw new ParseException("Error: La variable " + token.image + " no está definida.");
        }
    }
    
    return value; //Si se retorna -1 significa que el varCall() corresponde al parámetros de una función
  }
}

int value() throws Error:
{int value = -1;}
{
  (<NUM>
  {
    try
    {
      value = Integer.parseInt(token.image);
    }
   	catch (NumberFormatException ee) 
		{
			throw new Error("Hay overflow con el valor: "+token.image);
		}
	return value;
  }
  |<CONSTANT>
  {
    String image = token.image;
  	if (image.equals("dim")) { value = world.getN(); }
  	else if (image.equals("myxpos")) { value = (int) world.getPosition().getX(); }
  	else if (image.equals("myypos")) { value = (int) world.getPosition().getY(); }
  	else if (image.equals("mychips")) { value = world.getMyChips(); }
  	else if (image.equals("myballons")) { value = world.getMyBalloons(); }
  	else if (image.equals("ballonshere")) { value = world.countBalloons(); }
	else if (image.equals("chipshere")) { value = world.chipsToPick(); }
  	else if (image.equals("spaces")) { value = world.freeSpacesForChips(); }
  
	return value;
  }
  |value = varCall()
  {	return value; })//Si se retorna -1 significa que el varCall() corresponde al parámetros de una función
}

//value() retorna el valor numérico para usarlo con los métodos de world

Token direction():
{
  Token directionToken;
}
{
  directionToken = < DIRECTION >
  {
    if (!(token.image.equals(":front") || token.image.equals(":right") || token.image.equals(":left") || token.image.equals(":back"))) {
		throw new ParseException("Error: la dirección " + token.image + " no es válida con el comando move-dir o run-dirs.");
    }
    return directionToken;
  }
}

//Initial Rule
boolean command(Console sistema):
{}
{
	(<LPAREN>(varDefinition()|procedureDefinition()|instruction()) 
	{
	    try {
    			 Thread.sleep(900);
    	    } catch (InterruptedException e) {
    			        System.err.format("IOException: %s%n", e);
    		    }

		sistema.printOutput(salida);
		return true;
	})+

	| <EOF> {return false;} 
}

//void put() :
//{
//	int f=1;	
//}
//{
//	( <CHIPS>    "," f=num() {world.putChips(f); salida = "Command:  Put Chips"; })
//	|  	  ( <BALLOONS>   "," f=num() {world.putBalloons(f); salida = "Command:  Put Balloons";})	 
//
//}
//
//void get() :
//{
//	int f=1;	
//}
//{
//	( <CHIPS>   "," f=num() {world.pickChips(f);salida = "Command:  Pick chips";})
//	|  	  ( <BALLOONS>   "," f=num() {world.grabBalloons(f);salida="Command:  Pick balloons";})	 
//
//}
